// ----------------------------------------------------------------------------
// SystemC Testbench Header
//
//    HLS version: 2023.1_2/1049935 Production Release
//       HLS date: Sat Jun 10 10:53:51 PDT 2023
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 10.4
//
//   Generated by: ajh9498@hansolo.poly.edu
// Generated date: Wed Apr 23 23:11:18 EDT 2025
//
// ----------------------------------------------------------------------------
#ifdef CCS_SCVERIFY

// 
// -------------------------------------
// mc_testbench
// SCVerify mc_testbench SC_MODULE
// -------------------------------------
// 
#ifndef INCLUDED_MC_TESTBENCH_H
#define INCLUDED_MC_TESTBENCH_H

#ifdef __SYNTHESIS__
#error __SYNTHESIS__ is a predefined, reserved Catapult macro and cannot be user defined.
#endif

#ifndef SC_USE_STD_STRING
#define SC_USE_STD_STRING
#endif

#include "../../src/fir.h"
#include "ccs_testbench.h"
#include <systemc.h>
#include <tlm.h>
#include <ac_int.h>
#include <ac_fixed.h>
#include <mc_container_types.h>
#include <mc_typeconv.h>
#include <mc_transactors.h>
#include <mc_comparator.h>
#include <mc_end_of_testbench.h>
#include <vector>
#include <ac_read_env.h>


class mc_testbench : public sc_module
{
public:
   // Module instance pointers
   mc_comparator< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > , MaskPacket< 0, 11 > > *return_real_m_comp;
   mc_comparator< ac_int<5, true > , MaskPacket< 0, 5 > > *return_real_e_comp;
   mc_comparator< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > , MaskPacket< 0, 11 > > *return_imag_m_comp;
   mc_comparator< ac_int<5, true > , MaskPacket< 0, 5 > > *return_imag_e_comp;
   
   // Interface Ports
   sc_in< bool > clk;
   sc_port< tlm::tlm_fifo_put_if< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > > > ccs_input_real_m;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_input_real_m;
   sc_port< tlm::tlm_fifo_put_if< ac_int<5, true > > > ccs_input_real_e;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_input_real_e;
   sc_port< tlm::tlm_fifo_put_if< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > > > ccs_input_imag_m;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_input_imag_m;
   sc_port< tlm::tlm_fifo_put_if< ac_int<5, true > > > ccs_input_imag_e;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_input_imag_e;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<ac_fixed<11, 1, true, AC_TRN, AC_WRAP >,16> > > ccs_taps_real_m;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_taps_real_m;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<ac_int<5, true >,16> > > ccs_taps_real_e;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_taps_real_e;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<ac_fixed<11, 1, true, AC_TRN, AC_WRAP >,16> > > ccs_taps_imag_m;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_taps_imag_m;
   sc_port< tlm::tlm_fifo_put_if< mgc_sysc_ver_array1D<ac_int<5, true >,16> > > ccs_taps_imag_e;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_taps_imag_e;
   sc_port< tlm::tlm_fifo_get_if< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > > > ccs_return_real_m;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_return_real_m;
   sc_port< tlm::tlm_fifo_get_if< ac_int<5, true > > > ccs_return_real_e;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_return_real_e;
   sc_port< tlm::tlm_fifo_get_if< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > > > ccs_return_imag_m;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_return_imag_m;
   sc_port< tlm::tlm_fifo_get_if< ac_int<5, true > > > ccs_return_imag_e;
   sc_port< tlm::tlm_fifo_put_if< mc_wait_ctrl > > ccs_wait_ctrl_return_imag_e;
   sc_in< bool > design_is_idle;
   sc_out< sc_logic > enable_stalls;
   sc_in< unsigned short > stall_coverage;
   
   // Named Objects
   
   // Data objects
   int end_of_sim_wait_count;
   bool testbench_ended;
   int main_exit_code;
   bool atleast_one_active_input;
   sc_time last_event_time;
   sc_time last_event_time2;
   sc_signal< bool >                          cpp_testbench_active;
   sc_event testbench_end_event;
   sc_event testbench_aw_event;
   sc_event reset_request_event;
   bool _checked_results;
   bool _failed;
   static mc_testbench* that;
   bool _channel_mismatch;
   bool _capture_input_real_m;
   int input_real_m_capture_count;
   int input_real_m_iteration_count;
   bool _capture_input_real_e;
   int input_real_e_capture_count;
   int input_real_e_iteration_count;
   bool _capture_input_imag_m;
   int input_imag_m_capture_count;
   int input_imag_m_iteration_count;
   bool _capture_input_imag_e;
   int input_imag_e_capture_count;
   int input_imag_e_iteration_count;
   bool _capture_taps_real_m;
   int taps_real_m_capture_count;
   int taps_real_m_iteration_count;
   bool _capture_taps_real_e;
   int taps_real_e_capture_count;
   int taps_real_e_iteration_count;
   bool _capture_taps_imag_m;
   int taps_imag_m_capture_count;
   int taps_imag_m_iteration_count;
   bool _capture_taps_imag_e;
   int taps_imag_e_capture_count;
   int taps_imag_e_iteration_count;
   tlm::tlm_fifo< mc_golden_info< ac_fixed<11, 1, true, AC_TRN, AC_WRAP >, MaskPacket<0, 11> > > return_real_m_golden;
   bool _capture_return_real_m;
   int return_real_m_capture_count;
   int return_real_m_iteration_count;
   tlm::tlm_fifo< mc_golden_info< ac_int<5, true >, MaskPacket<0, 5> > > return_real_e_golden;
   bool _capture_return_real_e;
   int return_real_e_capture_count;
   int return_real_e_iteration_count;
   tlm::tlm_fifo< mc_golden_info< ac_fixed<11, 1, true, AC_TRN, AC_WRAP >, MaskPacket<0, 11> > > return_imag_m_golden;
   bool _capture_return_imag_m;
   int return_imag_m_capture_count;
   int return_imag_m_iteration_count;
   tlm::tlm_fifo< mc_golden_info< ac_int<5, true >, MaskPacket<0, 5> > > return_imag_e_golden;
   bool _capture_return_imag_e;
   int return_imag_e_capture_count;
   int return_imag_e_iteration_count;
   int wait_cnt;
   sc_time previous_timestamp;
   sc_time average_period;
   unsigned int period_counter;
   bool calculate_period;
   
   // Declare processes (SC_METHOD and SC_THREAD)
   void wait_for_end();
   void run();
   
   // Constructor
   SC_HAS_PROCESS(mc_testbench);
   mc_testbench(
      const sc_module_name& name
   )
      : clk("clk")
      , ccs_input_real_m("ccs_input_real_m")
      , ccs_wait_ctrl_input_real_m("ccs_wait_ctrl_input_real_m")
      , ccs_input_real_e("ccs_input_real_e")
      , ccs_wait_ctrl_input_real_e("ccs_wait_ctrl_input_real_e")
      , ccs_input_imag_m("ccs_input_imag_m")
      , ccs_wait_ctrl_input_imag_m("ccs_wait_ctrl_input_imag_m")
      , ccs_input_imag_e("ccs_input_imag_e")
      , ccs_wait_ctrl_input_imag_e("ccs_wait_ctrl_input_imag_e")
      , ccs_taps_real_m("ccs_taps_real_m")
      , ccs_wait_ctrl_taps_real_m("ccs_wait_ctrl_taps_real_m")
      , ccs_taps_real_e("ccs_taps_real_e")
      , ccs_wait_ctrl_taps_real_e("ccs_wait_ctrl_taps_real_e")
      , ccs_taps_imag_m("ccs_taps_imag_m")
      , ccs_wait_ctrl_taps_imag_m("ccs_wait_ctrl_taps_imag_m")
      , ccs_taps_imag_e("ccs_taps_imag_e")
      , ccs_wait_ctrl_taps_imag_e("ccs_wait_ctrl_taps_imag_e")
      , ccs_return_real_m("ccs_return_real_m")
      , ccs_wait_ctrl_return_real_m("ccs_wait_ctrl_return_real_m")
      , ccs_return_real_e("ccs_return_real_e")
      , ccs_wait_ctrl_return_real_e("ccs_wait_ctrl_return_real_e")
      , ccs_return_imag_m("ccs_return_imag_m")
      , ccs_wait_ctrl_return_imag_m("ccs_wait_ctrl_return_imag_m")
      , ccs_return_imag_e("ccs_return_imag_e")
      , ccs_wait_ctrl_return_imag_e("ccs_wait_ctrl_return_imag_e")
      , design_is_idle("design_is_idle")
      , enable_stalls("enable_stalls")
      , stall_coverage("stall_coverage")
      , cpp_testbench_active("cpp_testbench_active")
      , return_real_m_golden("return_real_m_golden",-1)
      , return_real_e_golden("return_real_e_golden",-1)
      , return_imag_m_golden("return_imag_m_golden",-1)
      , return_imag_e_golden("return_imag_e_golden",-1)
   {
      // Instantiate other modules
      return_real_m_comp = new mc_comparator< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > , MaskPacket< 0, 11 > > (
         "return_real_m_comp",
         "return_real_m",
         0,
         ac_env::read_int("SCVerify_MAX_ERROR_CNT",0),
         1
      );
      return_real_m_comp->data_in(ccs_return_real_m);
      return_real_m_comp->data_golden(return_real_m_golden);
      
      return_real_e_comp = new mc_comparator< ac_int<5, true > , MaskPacket< 0, 5 > > (
         "return_real_e_comp",
         "return_real_e",
         0,
         ac_env::read_int("SCVerify_MAX_ERROR_CNT",0),
         1
      );
      return_real_e_comp->data_in(ccs_return_real_e);
      return_real_e_comp->data_golden(return_real_e_golden);
      
      return_imag_m_comp = new mc_comparator< ac_fixed<11, 1, true, AC_TRN, AC_WRAP > , MaskPacket< 0, 11 > > (
         "return_imag_m_comp",
         "return_imag_m",
         0,
         ac_env::read_int("SCVerify_MAX_ERROR_CNT",0),
         1
      );
      return_imag_m_comp->data_in(ccs_return_imag_m);
      return_imag_m_comp->data_golden(return_imag_m_golden);
      
      return_imag_e_comp = new mc_comparator< ac_int<5, true > , MaskPacket< 0, 5 > > (
         "return_imag_e_comp",
         "return_imag_e",
         0,
         ac_env::read_int("SCVerify_MAX_ERROR_CNT",0),
         1
      );
      return_imag_e_comp->data_in(ccs_return_imag_e);
      return_imag_e_comp->data_golden(return_imag_e_golden);
      
      
      // Register processes
      SC_METHOD(wait_for_end);
      sensitive << clk.pos() << testbench_end_event;
      SC_THREAD(run);
      // Other constructor statements
      set_stack_size(64000000);
      _checked_results = false;
      that = this;
      end_of_sim_wait_count = 0;
      testbench_ended = false;
      main_exit_code = 0;
      atleast_one_active_input = true;
      _failed = false;
      _capture_input_real_m = true;
      _capture_input_real_e = true;
      _capture_input_imag_m = true;
      _capture_input_imag_e = true;
      _capture_taps_real_m = true;
      _capture_taps_real_e = true;
      _capture_taps_imag_m = true;
      _capture_taps_imag_e = true;
      _capture_return_real_m = true;
      _capture_return_real_e = true;
      _capture_return_imag_m = true;
      _capture_return_imag_e = true;
      wait_cnt = 0;
      previous_timestamp = SC_ZERO_TIME;
      average_period = SC_ZERO_TIME;
      period_counter = 0;
      calculate_period = true;
   }
   
   ~mc_testbench()
   {
      delete return_real_m_comp;
      return_real_m_comp = 0;
      delete return_real_e_comp;
      return_real_e_comp = 0;
      delete return_imag_m_comp;
      return_imag_m_comp = 0;
      delete return_imag_e_comp;
      return_imag_e_comp = 0;
   }
   
   // C++ class functions
   public:
      static void wait_for_idle_sync() ;
   public:
      static void set_enable_stalls(bool flag) ;
   public:
      void reset_request() ;
   public:
      void capture_input(my_complex_float_t input) ;
   public:
      void capture_taps( my_complex_float_t taps[16]) ;
   public:
      void capture__TOP__return(my_complex_float_t _TOP__return) ;
   protected:
      void wait_on_input_required() ;
   public:
      static void capture_IN(my_complex_float_t input, my_complex_float_t taps[16]) ;
   public:
      static void capture_OUT(my_complex_float_t _TOP__return, my_complex_float_t input, my_complex_float_t taps[16]) ;
   public:
      static my_complex_float_t exec_fir(my_complex_float_t input, my_complex_float_t taps[16]) ;
   protected:
      void start_of_simulation() ;
   protected:
      void end_of_simulation() ;
   public:
      void check_results() ;
   public:
      bool failed() ;
   public:
      void set_failed(bool fail) ;
};
#endif
#endif //CCS_SCVERIFY

// ----------------------------------------------------------------------------
// SystemC Testbench Body
//
//    HLS version: 2023.1_2/1049935 Production Release
//       HLS date: Sat Jun 10 10:53:51 PDT 2023
//  Flow Packages: HDL_Tcl 8.0a, SCVerify 10.4
//
//   Generated by: ajh9498@hansolo.poly.edu
// Generated date: Wed Apr 23 22:57:07 EDT 2025
//
// ----------------------------------------------------------------------------
// 
// -------------------------------------
// mc_testbench
// SCVerify mc_testbench SC_MODULE
// -------------------------------------
// 
#include "mc_testbench.h"
#include <mc_testbench_util.h>
#include <mc_simulator_extensions.h>

mc_testbench* mc_testbench::that;
bool testbench::enable_idle_sync_mode;
unsigned short testbench::idle_sync_stable_cycles;
void testbench::set_enable_stalls(bool flag) { mc_testbench::set_enable_stalls(flag); }
void testbench::reset_request() { mc_testbench::that->reset_request(); }
void mc_testbench_reset_request() { mc_testbench::that->reset_request(); }
bool testbench::_dut_inst = false;
bool testbench::dut_inst() { return _dut_inst; }
bool mc_testbench_dut_inst() { return testbench::dut_inst(); }
bool testbench::set_dut_inst( bool _inst ) { if(_dut_inst==false) _dut_inst=_inst; return _dut_inst; }
bool mc_testbench_set_dut_inst( bool _inst ) { return testbench::set_dut_inst(_inst); }
void mc_testbench_wait_for_idle_sync() { mc_testbench::wait_for_idle_sync(); }
bool testbench::input_m_ignore;
void mc_testbench_input_m_skip(bool v) { testbench::input_m_skip = v; }
bool testbench::input_m_skip;
bool testbench::input_m_skip_quiet;
bool testbench::input_m_skip_once;
bool testbench::input_m_skip_noerr;
int  testbench::input_m_array_comp_first;
int  testbench::input_m_array_comp_last;
mc_wait_ctrl testbench::input_m_wait_ctrl;
bool testbench::input_e_ignore;
void mc_testbench_input_e_skip(bool v) { testbench::input_e_skip = v; }
bool testbench::input_e_skip;
bool testbench::input_e_skip_quiet;
bool testbench::input_e_skip_once;
bool testbench::input_e_skip_noerr;
int  testbench::input_e_array_comp_first;
int  testbench::input_e_array_comp_last;
mc_wait_ctrl testbench::input_e_wait_ctrl;
bool testbench::taps_m_ignore;
void mc_testbench_taps_m_skip(bool v) { testbench::taps_m_skip = v; }
bool testbench::taps_m_skip;
bool testbench::taps_m_skip_quiet;
bool testbench::taps_m_skip_once;
bool testbench::taps_m_skip_noerr;
int  testbench::taps_m_array_comp_first;
int  testbench::taps_m_array_comp_last;
mc_wait_ctrl testbench::taps_m_wait_ctrl;
bool testbench::taps_e_ignore;
void mc_testbench_taps_e_skip(bool v) { testbench::taps_e_skip = v; }
bool testbench::taps_e_skip;
bool testbench::taps_e_skip_quiet;
bool testbench::taps_e_skip_once;
bool testbench::taps_e_skip_noerr;
int  testbench::taps_e_array_comp_first;
int  testbench::taps_e_array_comp_last;
mc_wait_ctrl testbench::taps_e_wait_ctrl;
bool testbench::return_m_ignore;
void mc_testbench_return_m_skip(bool v) { testbench::return_m_skip = v; }
bool testbench::return_m_skip;
bool testbench::return_m_skip_quiet;
bool testbench::return_m_skip_once;
bool testbench::return_m_skip_noerr;
int  testbench::return_m_array_comp_first;
int  testbench::return_m_array_comp_last;
bool testbench::return_m_use_mask;
ac_fixed<11, 1, true, AC_TRN, AC_WRAP > testbench::return_m_output_mask;
mc_wait_ctrl testbench::return_m_wait_ctrl;
bool testbench::return_e_ignore;
void mc_testbench_return_e_skip(bool v) { testbench::return_e_skip = v; }
bool testbench::return_e_skip;
bool testbench::return_e_skip_quiet;
bool testbench::return_e_skip_once;
bool testbench::return_e_skip_noerr;
int  testbench::return_e_array_comp_first;
int  testbench::return_e_array_comp_last;
bool testbench::return_e_use_mask;
ac_int<5, true > testbench::return_e_output_mask;
mc_wait_ctrl testbench::return_e_wait_ctrl;
#ifndef CCS_SCVERIFY_USE_CCS_BLOCK
extern "C++" ac_float<11, 1, 5, AC_TRN > fir(ac_float<11, 1, 5, AC_TRN> input, ac_float<11, 1, 5, AC_TRN> taps[32]);
#endif
#ifndef CCS_SCVERIFY_USE_CCS_BLOCK
ac_float<11, 1, 5, AC_TRN> testbench::exec_fir(ac_float<11, 1, 5, AC_TRN> input, ac_float<11, 1, 5, AC_TRN> taps[32]) {
   return mc_testbench::exec_fir(input, taps);
}
#endif

// ============================================
// Function: wait_for_idle_sync
// --------------------------------------------

void mc_testbench::wait_for_idle_sync()
{
   if (testbench::enable_idle_sync_mode) {
     std::cout << "mc_testbench: Idle synchronization disabled, requires design with stall controls." << std::endl;
     testbench::enable_idle_sync_mode = false;
     that->cpp_testbench_active.write(true);
   }
}
// ============================================
// Function: set_enable_stalls
// --------------------------------------------

void mc_testbench::set_enable_stalls(bool flag)
{
   if (flag) {
     std::cout << "Enabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_1);
   } else {
     std::cout << "Disabling STALL_FLAG toggling" << std::endl;
     that->enable_stalls.write(sc_dt::Log_0);
   }
}
// ============================================
// Function: reset_request
// --------------------------------------------

void mc_testbench::reset_request()
{
   reset_request_event.notify(0,SC_NS);
}
// ============================================
// Function: capture_input
// --------------------------------------------

void mc_testbench::capture_input(ac_float<11, 1, 5, AC_TRN > input)
{
   if (input_m_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_input_m && !testbench::input_m_ignore)
   {
      int cur_iter = input_m_iteration_count;
      ++input_m_iteration_count;
      ccs_input_m->put(input.ac_float<11, 1, 5, AC_TRN >::m); // THIS
      ++input_m_capture_count;
      mc_testbench_util::process_wait_ctrl("input_m",testbench::input_m_wait_ctrl,ccs_wait_ctrl_input_m.operator->(),cur_iter,input_m_capture_count,0);
   }
   testbench::input_m_ignore = false;
   if (_capture_input_e && !testbench::input_e_ignore)
   {
      int cur_iter = input_e_iteration_count;
      ++input_e_iteration_count;
      ccs_input_e->put(input.ac_float<11, 1, 5, AC_TRN >::e); // THIS
      ++input_e_capture_count;
      mc_testbench_util::process_wait_ctrl("input_e",testbench::input_e_wait_ctrl,ccs_wait_ctrl_input_e.operator->(),cur_iter,input_e_capture_count,0);
   }
   testbench::input_e_ignore = false;
}
// ============================================
// Function: capture_taps
// --------------------------------------------

void mc_testbench::capture_taps( ac_float<11, 1, 5, AC_TRN > taps[32])
{
   if (taps_m_capture_count == wait_cnt)
      wait_on_input_required();
   if (_capture_taps_m && !testbench::taps_m_ignore)
   {
      int cur_iter = taps_m_iteration_count;
      ++taps_m_iteration_count;
      mgc_sysc_ver_array1D<ac_fixed<11, 1, true, AC_TRN, AC_WRAP >,32> taps_m_tmp;
      int taps_linear_idx = 0;
      for (int taps_idx_0 = 0; taps_idx_0 < 32; ++taps_idx_0)
         taps_m_tmp[taps_linear_idx++] = taps[taps_idx_0].ac_float<11, 1, 5, AC_TRN >::m;
      ccs_taps_m->put(taps_m_tmp);
      ++taps_m_capture_count;
      mc_testbench_util::process_wait_ctrl("taps_m",testbench::taps_m_wait_ctrl,ccs_wait_ctrl_taps_m.operator->(),cur_iter,taps_m_capture_count,0);
   }
   testbench::taps_m_ignore = false;
   if (_capture_taps_e && !testbench::taps_e_ignore)
   {
      int cur_iter = taps_e_iteration_count;
      ++taps_e_iteration_count;
      mgc_sysc_ver_array1D<ac_int<5, true >,32> taps_e_tmp;
      int taps_linear_idx = 0;
      for (int taps_idx_0 = 0; taps_idx_0 < 32; ++taps_idx_0)
         taps_e_tmp[taps_linear_idx++] = taps[taps_idx_0].ac_float<11, 1, 5, AC_TRN >::e;
      ccs_taps_e->put(taps_e_tmp);
      ++taps_e_capture_count;
      mc_testbench_util::process_wait_ctrl("taps_e",testbench::taps_e_wait_ctrl,ccs_wait_ctrl_taps_e.operator->(),cur_iter,taps_e_capture_count,0);
   }
   testbench::taps_e_ignore = false;
}
// ============================================
// Function: capture__TOP__return
// --------------------------------------------

void mc_testbench::capture__TOP__return(ac_float<11, 1, 5, AC_TRN > _TOP__return)
{
   if (_capture_return_m)
   {
      int cur_iter = return_m_iteration_count;
      ++return_m_iteration_count;
      mc_golden_info< ac_fixed<11, 1, true, AC_TRN, AC_WRAP >, MaskPacket<0, 11> > return_m_tmp(_TOP__return.ac_float<11, 1, 5, AC_TRN >::m, testbench::return_m_ignore, false, return_m_iteration_count);
      // BEGIN: testbench output_mask control for field_name return_m
      if ( testbench::return_m_use_mask ) {
         sc_lv<11> tmp_mask_lv;
         type_to_vector(testbench::return_m_output_mask, 11, tmp_mask_lv);
         return_m_tmp._use_mask = true;
         return_m_tmp._packet._mask = tmp_mask_lv;
      }
      // END: testbench output_mask control for field_name return_m
      if (!testbench::return_m_skip) {
         return_m_golden.put(return_m_tmp);
         ++return_m_capture_count;
      } else {
         if (!testbench::return_m_skip_quiet || !testbench::return_m_skip_once) {
            std::ostringstream msg; msg.str("");
            msg << "testbench::return_m_skip=true for iteration=" << return_m_iteration_count << " @ " << sc_time_stamp();
            SC_REPORT_WARNING("User testbench", msg.str().c_str());
            testbench::return_m_skip_once = true;
         }
      }
      mc_testbench_util::process_wait_ctrl("return_m",testbench::return_m_wait_ctrl,ccs_wait_ctrl_return_m.operator->(),cur_iter,return_m_capture_count,0);
      testbench::return_m_use_mask = false;
   }
   testbench::return_m_ignore = false;
   testbench::return_m_skip = false;
   if (_capture_return_e)
   {
      int cur_iter = return_e_iteration_count;
      ++return_e_iteration_count;
      mc_golden_info< ac_int<5, true >, MaskPacket<0, 5> > return_e_tmp(_TOP__return.ac_float<11, 1, 5, AC_TRN >::e, testbench::return_e_ignore, false, return_e_iteration_count);
      // BEGIN: testbench output_mask control for field_name return_e
      if ( testbench::return_e_use_mask ) {
         sc_lv<5> tmp_mask_lv;
         type_to_vector(testbench::return_e_output_mask, 5, tmp_mask_lv);
         return_e_tmp._use_mask = true;
         return_e_tmp._packet._mask = tmp_mask_lv;
      }
      // END: testbench output_mask control for field_name return_e
      if (!testbench::return_e_skip) {
         return_e_golden.put(return_e_tmp);
         ++return_e_capture_count;
      } else {
         if (!testbench::return_e_skip_quiet || !testbench::return_e_skip_once) {
            std::ostringstream msg; msg.str("");
            msg << "testbench::return_e_skip=true for iteration=" << return_e_iteration_count << " @ " << sc_time_stamp();
            SC_REPORT_WARNING("User testbench", msg.str().c_str());
            testbench::return_e_skip_once = true;
         }
      }
      mc_testbench_util::process_wait_ctrl("return_e",testbench::return_e_wait_ctrl,ccs_wait_ctrl_return_e.operator->(),cur_iter,return_e_capture_count,0);
      testbench::return_e_use_mask = false;
   }
   testbench::return_e_ignore = false;
   testbench::return_e_skip = false;
}
// ============================================
// Function: wait_on_input_required
// --------------------------------------------

void mc_testbench::wait_on_input_required()
{
   ++wait_cnt;
   wait(SC_ZERO_TIME); // get fifos a chance to update
   ++period_counter;
   sc_time timeout = sc_time_stamp() - previous_timestamp;
   if (calculate_period && sc_time_stamp() > SC_ZERO_TIME && sc_time_stamp() != previous_timestamp && sc_time_stamp() != timeout) {
      average_period = (average_period + timeout) / 2;
   }
   previous_timestamp = sc_time_stamp();
   while (atleast_one_active_input) {
      if (_capture_input_m && ccs_input_m->used() == 0) return;
      if (_capture_input_e && ccs_input_e->used() == 0) return;
      if (_capture_taps_m && ccs_taps_m->used() == 0) return;
      if (_capture_taps_e && ccs_taps_e->used() == 0) return;
      that->cpp_testbench_active.write(false);
      if (average_period > SC_ZERO_TIME && sc_time_stamp() != timeout)
         wait(average_period * 10, ccs_input_m->ok_to_put() | ccs_input_e->ok_to_put() | ccs_taps_m->ok_to_put() | ccs_taps_e->ok_to_put());
      else
         wait(ccs_input_m->ok_to_put() | ccs_input_e->ok_to_put() | ccs_taps_m->ok_to_put() | ccs_taps_e->ok_to_put());
      that->cpp_testbench_active.write(true);
      if (timed_out()) {
         calculate_period = false;
         return;
      }
   }
}
// ============================================
// Function: capture_IN
// --------------------------------------------

void mc_testbench::capture_IN(ac_float<11, 1, 5, AC_TRN> input, ac_float<11, 1, 5, AC_TRN> taps[32])
{
   that->capture_input(input);
   that->capture_taps(taps);
}
// ============================================
// Function: capture_OUT
// --------------------------------------------

void mc_testbench::capture_OUT(ac_float<11, 1, 5, AC_TRN> _TOP__return, ac_float<11, 1, 5, AC_TRN> input, ac_float<11, 1, 5, AC_TRN> taps[32])
{
   that->capture__TOP__return(_TOP__return);
}
// ============================================
// Function: exec_fir
// --------------------------------------------

ac_float<11, 1, 5, AC_TRN> mc_testbench::exec_fir(ac_float<11, 1, 5, AC_TRN> input, ac_float<11, 1, 5, AC_TRN> taps[32])
{
   #ifndef CCS_SCVERIFY_USE_CCS_BLOCK
   wait_for_idle_sync();
   capture_IN(input, taps);
   ac_float<11, 1, 5, AC_TRN> _TOP__return = fir(input, taps);
   // throttle ac_channel based on number of calls to chan::size() or chan::empty() or chan::nb_read() (but not chan::available()) 
   if (1) {
      int cnt=0;
      if (cnt) std::cout << "mc_testbench.cpp: CONTINUES @ " << sc_time_stamp() << std::endl;
      if (cnt) that->cpp_testbench_active.write(true);
   }
   capture_OUT(_TOP__return, input, taps);
   return _TOP__return;
   #else
   ac_float<11, 1, 5, AC_TRN> _TOP__return;
   return _TOP__return;
   #endif
}
// ============================================
// Function: start_of_simulation
// --------------------------------------------

void mc_testbench::start_of_simulation()
{
   set_enable_stalls(false);
   if (ac_env::read_int("SCVerify_AUTOWAIT", 0) != 0) { //explicitly 0 means off
      SC_REPORT_INFO(name(), "SCVerify AUTOWAIT is enabled for this simulation.");
   }
}
// ============================================
// Function: end_of_simulation
// --------------------------------------------

void mc_testbench::end_of_simulation()
{
   if (!_checked_results) {
      SC_REPORT_INFO(name(), "Testbench exited early or ran into deadlock");
      check_results();
   }
}
// ============================================
// Function: check_results
// --------------------------------------------

void mc_testbench::check_results()
{
   if (_checked_results) return;
   _checked_results = true;
   cout<<endl;
   cout<<"Checking results"<<endl;
   if (main_exit_code) _failed = true;
   int _num_outputs_checked = 0;
   bool _has_capture_counts = false;
   std::ostringstream mctb_msg;
   
   if (!_capture_return_m) {
      cout<<"'return_m' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed |= return_m_comp->check_results(return_m_capture_count,testbench::return_m_skip_noerr);
      _has_capture_counts |= !!(return_m_capture_count);
   }
   if (!_capture_return_e) {
      cout<<"'return_e' - warning, output was optimized away"<<endl;
   } else {
      _num_outputs_checked++;
      _failed |= return_e_comp->check_results(return_e_capture_count,testbench::return_e_skip_noerr);
      _has_capture_counts |= !!(return_e_capture_count);
   }
   cout<<endl;
   if (_num_outputs_checked == 0) {
      cout<<"Error: All outputs were optimized away. No output values were compared."<<endl;
      _failed = _failed || (_num_outputs_checked == 0);
   }
   if (!_has_capture_counts) {
      cout<<"Error: Nothing to compare, all output capture counts are zero."<<endl;
      _failed = true;
   }
   if (main_exit_code) cout << "Error: C++ Testbench 'main()' returned a non-zero exit code ("<<main_exit_code<<"). Check your testbench." <<endl;
   mctb_msg.clear();
   if (_failed) mctb_msg << "Simulation FAILED";
   else         mctb_msg << "Simulation PASSED";
   mctb_msg << " @ " << sc_time_stamp();
   if (_channel_mismatch && _failed)
      mctb_msg << endl << "An input channel was switched before the input fifo was fully empty. Check your testbench.";
   SC_REPORT_INFO(this->name(), mctb_msg.str().c_str());
}
// ============================================
// Function: failed
// --------------------------------------------

bool mc_testbench::failed()
{
   return _failed;
}
// ============================================
// Function: set_failed
// --------------------------------------------

void mc_testbench::set_failed(bool fail)
{
   _failed = fail;
}
// ---------------------------------------------------------------
// Process: SC_METHOD wait_for_end
// Static sensitivity: sensitive << clk.pos() << testbench_end_event;

void mc_testbench::wait_for_end() {
   #ifdef VCS_SYSTEMC
   if (!hdl_elaboration_only()) {
   #endif
   // If run() has not finished, we do nothing here
   if (!testbench_ended) return;
   // check for completed outputs
   if (return_m_comp->get_compare_count() < return_m_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   if (return_e_comp->get_compare_count() < return_e_capture_count) {testbench_end_event.notify(1,SC_NS); return;}
   // If we made it here, all outputs have flushed. Check the results
   testbench_aw_event.notify(SC_ZERO_TIME);
   SC_REPORT_INFO(name(), "Simulation completed");
   check_results();
   #ifdef VCS_SYSTEMC
   }
   #endif
   sc_stop();
}
// ---------------------------------------------------------------
// Process: SC_THREAD run
// Static sensitivity: 

void mc_testbench::run() {
   testbench::enable_idle_sync_mode = false;
   testbench::idle_sync_stable_cycles = 1;
   _channel_mismatch = false;
   testbench::input_m_ignore = false;
   testbench::input_m_skip = false;
   testbench::input_m_skip_quiet = false;
   testbench::input_m_skip_once = false;
   testbench::input_m_skip_noerr = false;
   testbench::input_m_array_comp_first = -1;
   testbench::input_m_array_comp_last = -1;
   testbench::input_m_wait_ctrl.clear();
   input_m_capture_count = 0;
   input_m_iteration_count = 0;
   testbench::input_e_ignore = false;
   testbench::input_e_skip = false;
   testbench::input_e_skip_quiet = false;
   testbench::input_e_skip_once = false;
   testbench::input_e_skip_noerr = false;
   testbench::input_e_array_comp_first = -1;
   testbench::input_e_array_comp_last = -1;
   testbench::input_e_wait_ctrl.clear();
   input_e_capture_count = 0;
   input_e_iteration_count = 0;
   testbench::taps_m_ignore = false;
   testbench::taps_m_skip = false;
   testbench::taps_m_skip_quiet = false;
   testbench::taps_m_skip_once = false;
   testbench::taps_m_skip_noerr = false;
   testbench::taps_m_array_comp_first = -1;
   testbench::taps_m_array_comp_last = -1;
   testbench::taps_m_wait_ctrl.clear();
   taps_m_capture_count = 0;
   taps_m_iteration_count = 0;
   testbench::taps_e_ignore = false;
   testbench::taps_e_skip = false;
   testbench::taps_e_skip_quiet = false;
   testbench::taps_e_skip_once = false;
   testbench::taps_e_skip_noerr = false;
   testbench::taps_e_array_comp_first = -1;
   testbench::taps_e_array_comp_last = -1;
   testbench::taps_e_wait_ctrl.clear();
   taps_e_capture_count = 0;
   taps_e_iteration_count = 0;
   testbench::return_m_ignore = false;
   testbench::return_m_skip = false;
   testbench::return_m_skip_quiet = false;
   testbench::return_m_skip_once = false;
   testbench::return_m_skip_noerr = false;
   testbench::return_m_array_comp_first = -1;
   testbench::return_m_array_comp_last = -1;
   testbench::return_m_use_mask = false;
   testbench::return_m_output_mask = (ac_fixed<11, 1, true, AC_TRN, AC_WRAP >) ~0;
   testbench::return_m_wait_ctrl.clear();
   return_m_capture_count = 0;
   return_m_iteration_count = 0;
   testbench::return_e_ignore = false;
   testbench::return_e_skip = false;
   testbench::return_e_skip_quiet = false;
   testbench::return_e_skip_once = false;
   testbench::return_e_skip_noerr = false;
   testbench::return_e_array_comp_first = -1;
   testbench::return_e_array_comp_last = -1;
   testbench::return_e_use_mask = false;
   testbench::return_e_output_mask = (ac_int<5, true >) ~0;
   testbench::return_e_wait_ctrl.clear();
   return_e_capture_count = 0;
   return_e_iteration_count = 0;
   testbench testbench_inst(sc_argc(), sc_argv());
   main_exit_code = testbench_inst.main();
   cout<<"Info: Execution of user-supplied C++ testbench 'main()' has completed with exit code = " << main_exit_code << endl;
   cout<<endl;
   cout<<"Info: Collecting data completed"<<endl;
   cout<<"   captured "<<input_m_capture_count<<" values of input_m"<<endl;
   cout<<"   captured "<<input_e_capture_count<<" values of input_e"<<endl;
   cout<<"   captured "<<taps_m_capture_count<<" values of taps_m"<<endl;
   cout<<"   captured "<<taps_e_capture_count<<" values of taps_e"<<endl;
   cout<<"   captured "<<return_m_capture_count<<" values of return_m"<<endl;
   cout<<"   captured "<<return_e_capture_count<<" values of return_e"<<endl;
   testbench_ended = true;
   testbench_end_event.notify(SC_ZERO_TIME);
}
#ifdef CCS_SCVERIFY_USE_CCS_BLOCK
#include "ccs_block_macros.cpp"
#endif
